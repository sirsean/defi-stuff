# Trade Recommendations Persistence

**Created**: 2025-10-05  
**Status**: Planning Complete / Implementation Ready

## Summary

Add database persistence for AI-generated trade recommendations to enable historical analysis, performance tracking, and future automation of trading strategies. This feature will save recommendations generated by the `trade:recommend` command to a SQLite database when the `--db` flag is passed.

## Goals

1. **Track Recommendation History**: Store all AI recommendations with full context (market, price, action, confidence, reasoning)
2. **Enable Performance Analysis**: Compare recommendations against actual market outcomes
3. **Support Future Features**: Foundation for automated trading, backtesting, and strategy refinement
4. **Maintain CLI Simplicity**: Opt-in persistence via `--db` flag, no impact on default behavior

## Database Schema

### Table: `trade_recommendations`

| Column          | Type              | Constraints           | Description                                    |
|-----------------|-------------------|-----------------------|------------------------------------------------|
| `id`            | INTEGER           | PRIMARY KEY AUTOINCR  | Unique identifier                              |
| `timestamp`     | TIMESTAMP         | NOT NULL DEFAULT NOW  | When recommendation was generated              |
| `market`        | VARCHAR(255)      | NOT NULL              | Market symbol (e.g., "BTC", "ETH")             |
| `price`         | DECIMAL(30, 10)   | NOT NULL              | Current market price at time of recommendation |
| `action`        | VARCHAR(20)       | NOT NULL              | Trade direction: long/short/hold/close         |
| `confidence`    | DECIMAL(5, 4)     | NOT NULL              | Confidence score (0.0 to 1.0)                  |
| `size_usd`      | DECIMAL(30, 10)   | NULLABLE              | Suggested position size in USD                 |
| `timeframe`     | VARCHAR(20)       | NOT NULL              | Expected holding period: intraday/short/long   |
| `reasoning`     | TEXT              | NOT NULL              | AI-generated explanation                       |
| `risk_factors`  | JSON              | NULLABLE              | Array of risk factors that could invalidate   |

### Indexes

- `tr_market_idx` on `market` - Fast filtering by market
- `tr_timestamp_idx` on `timestamp` - Chronological queries
- `tr_action_idx` on `action` - Analysis by action type

### Storage Notes

- **Decimals**: SQLite uses NUMERIC affinity; store as strings for precision
- **JSON**: SQLite 3.38+ has native JSON support; fallback to TEXT for older versions
- **Future Enhancement**: Consider composite index on `(market, timestamp)` for time-series queries

## Service Design

### File: `src/db/tradeRecommendationService.ts`

Service class following the repository pattern established in `balanceRecordService.ts`.

#### Interface: `TradeRecommendationRecord`

Maps directly to database columns with proper typing:

```typescript
export interface TradeRecommendationRecord {
  id?: number;
  timestamp: Date | string;
  market: string;
  price: number;
  action: 'long' | 'short' | 'hold' | 'close';
  confidence: number;
  size_usd: number | null;
  timeframe: 'intraday' | 'short' | 'medium' | 'long';
  reasoning: string;
  risk_factors: string[] | null;
}
```

#### Class: `TradeRecommendationService`

**Core Methods:**

- `saveRecommendation(rec)`: Insert single recommendation
- `saveRecommendations(recs)`: Bulk insert in transaction
- `getRecommendationsByMarket(market, limit)`: Filter by market symbol
- `getRecommendationsByDateRange(start, end)`: Time-range queries
- `getLatestRecommendations(limit)`: Most recent across all markets

**Design Principles:**

- Uses `KnexConnector` for database access (matches existing services)
- Maps domain types (`TradeRecommendation`) to database records
- Graceful error handling with detailed logging
- Transaction support for batch operations

## CLI Changes

### Command: `trade:recommend`

**New Option:**

```bash
--db    Persist generated trade recommendations to the database
```

**Updated Interface:**

```typescript
interface TradeRecommendationOptions {
  markets?: string;
  address?: string;
  subs?: string;
  json?: boolean;
  db?: boolean;  // NEW
}
```

**Behavior:**

- `--db` absent: Current behavior (console output only)
- `--db` present: Console output + database persistence
- Database errors logged but don't prevent console output
- Graceful connection cleanup on exit

## Implementation Checklist

- [x] Planning document created
- [ ] Migration file generated (`npx knex migrate:make`)
- [ ] Migration implemented with schema and indexes
- [ ] Migration applied locally (`npm run db:migrate`)
- [ ] Service class created (`src/db/tradeRecommendationService.ts`)
- [ ] Service typed and implements all CRUD methods
- [ ] CLI option `--db` added in `src/index.ts`
- [ ] Command integration in `src/commands/tradeRecommendation.ts`
- [ ] Manual testing with `npm run dev -- trade:recommend --db`
- [ ] Database records verified in SQLite
- [ ] Unit tests added (`test/db/tradeRecommendationService.test.ts`)
- [ ] All tests passing (`npm test`)
- [ ] Type checking passing (`npm run lint`)
- [ ] Build successful (`npm run build`)
- [ ] Ready for review

## Testing Plan

### 1. Migration Testing

```bash
# Apply migration
npm run db:migrate

# Verify table exists
sqlite3 db/defi_data_dev.sqlite3 ".schema trade_recommendations"

# Test rollback
npm run db:rollback

# Reapply
npm run db:migrate
```

### 2. Integration Testing

```bash
# Generate and persist recommendations
npm run dev -- trade:recommend --db

# Query database directly
sqlite3 db/defi_data_dev.sqlite3 "SELECT * FROM trade_recommendations ORDER BY timestamp DESC LIMIT 5;"
```

### 3. Unit Testing

Create `test/db/tradeRecommendationService.test.ts` with:

- Test in-memory SQLite database
- Test single insert with all fields populated
- Test bulk insert with multiple recommendations
- Test query methods (by market, by date range, latest)
- Test error handling for invalid data
- Test JSON serialization of `risk_factors`

### 4. End-to-End Testing

```bash
# Full workflow
npm run build
node dist/index.js trade:recommend --markets BTC,ETH --db

# Verify output includes both console display and DB confirmation
```

## Usage Examples

### Save Recommendations for Default Markets (BTC, ETH)

```bash
npm run dev -- trade:recommend --db
```

**Output:**
```
ðŸ¤– Generating trade recommendations...
[... normal console output ...]
âœ… Saved 2 trade recommendations to database
```

### Save Recommendations for Specific Markets

```bash
npm run dev -- trade:recommend --markets BTC,ETH,SOL --db
```

### Query Historical Recommendations (Example Script)

```typescript
import { tradeRecommendationService } from './src/db/tradeRecommendationService.js';

// Get last 10 BTC recommendations
const btcRecs = await tradeRecommendationService.getRecommendationsByMarket('BTC', 10);

// Get recommendations from last 7 days
const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
const recentRecs = await tradeRecommendationService.getRecommendationsByDateRange(
  weekAgo,
  new Date()
);

console.log(`BTC recommendations: ${btcRecs.length}`);
console.log(`Recent recommendations: ${recentRecs.length}`);
```

## Future Enhancements

### Phase 2: Analysis Commands

- `trade:history --market BTC`: Show recommendation history for a market
- `trade:performance`: Compare recommendations vs actual outcomes
- `trade:backtest`: Simulate following recommendations historically

### Phase 3: Automated Trading

- `trade:auto --enabled`: Enable automated execution based on high-confidence recommendations
- Integration with existing Flex trading commands
- Position size optimization based on portfolio balance
- Risk management rules (max positions, leverage limits)

### Phase 4: Reporting

- Daily summary of recommendations sent to Discord
- Weekly performance reports
- Alert system for high-confidence opportunities

## Architecture Notes

### Why This Design?

1. **Separation of Concerns**: Service layer isolates database logic from CLI commands
2. **Consistency**: Matches existing `balanceRecordService` pattern
3. **Testability**: Service methods easily tested in isolation
4. **Extensibility**: Easy to add query methods as needs evolve
5. **Opt-in**: `--db` flag means no breaking changes to existing workflows

### Integration Points

- **Types**: Reuses `TradeRecommendation` from `src/types/tradeRecommendation.ts`
- **Database**: Uses existing Knex.js infrastructure and connection pooling
- **Migration**: Follows established pattern from `balance_records` migration
- **Service**: Models after `BalanceRecordService` and `DailyBalanceService`
- **CLI**: Follows Commander.js patterns in `src/index.ts`

### Error Handling Strategy

- Database errors don't prevent console output (user always sees recommendations)
- Errors logged with context for debugging
- Graceful degradation if database unavailable
- Transaction rollback on batch insert failures

## Dependencies

**No new dependencies required!**

All functionality uses existing packages:
- `knex` - Database operations
- `sqlite3` - SQLite driver
- `commander` - CLI parsing

## Migration Path

1. **Development**: Test locally with dev database
2. **Production**: Run `npm run db:migrate` before deploying
3. **Rollback**: Available via `npm run db:rollback` if issues arise
4. **Monitoring**: Check logs for `[db] Saved N trade recommendations` confirmations

## Success Criteria

- âœ… Migration creates table successfully
- âœ… Service saves recommendations without errors
- âœ… All recommendation fields persisted correctly
- âœ… Queries return expected results
- âœ… CLI behavior unchanged when `--db` not used
- âœ… CLI behavior adds persistence when `--db` used
- âœ… Unit tests pass
- âœ… Build completes without errors
- âœ… Manual verification in SQLite shows correct data

---

**Next Steps**: Begin implementation starting with migration generation.
